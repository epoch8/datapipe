# Стратегия фиксации офсетов

**Расположение в коде:** `datapipe/step/batch_transform.py:740-789`

[← Назад к обзору](./offset-optimization.md)

---

## Текущая стратегия: Атомарная фиксация в конце run_full

**Принцип:** Офсеты фиксируются **только после успешной обработки всех батчей**.

```python
def run_full(self, ds, run_config=None, executor=None):
    idx = self.get_changed_idx(ds, run_config)
    changes = executor.run_process_batch(...)

    # Фиксация офсетов ТОЛЬКО в конце
    if changes.offsets:
        ds.offset_table.update_offsets_bulk(changes.offsets)

    return changes
```

### Гарантии

✅ **Нет потери данных** — при сбое в середине обработки офсет не изменяется, данные переобработаются

✅ **Изоляция от run_changelist** — `run_changelist` не трогает офсеты, только `run_full` обновляет их

✅ **Корректное восстановление** — после перезапуска обработка продолжается с последнего гарантированно завершенного run_full

### Проблема

**Сценарий:**
```
Обработка 1000 батчей:
  - Батчи 1-998: ✅ Успешно обработаны
  - Батч 999: ❌ CRASH!
  - Батч 1000: ❌ Не запустился

Офсет НЕ зафиксирован (crash до конца run_full)

После перезапуска:
  - Все 1000 батчей переобрабатываются с начала
  - Потеря прогресса обработки 998 батчей
```

**Вывод:** При обработке больших таблиц риск потери значительного прогресса.

---

## Планы развития: Побатчевый коммит офсетов

**Цель:** Фиксировать офсет после каждого успешно обработанного батча.

### Планируемая реализация

```python
def store_batch_result(...):
    # Обработка и сохранение данных
    ...

    # Вычислить офсеты для текущего батча
    batch_offsets = self._get_max_update_ts_for_batch(ds, idx, new_idx)

    # НОВОЕ: Фиксировать офсет сразу после успешной обработки батча
    if batch_offsets and use_per_batch_offset_commit:
        ds.offset_table.update_offsets_bulk(batch_offsets)
        logger.info(f"Updated offsets after batch: {batch_offsets}")

    return ChangeList(
        changes={self.name: new_idx},
        offsets=batch_offsets
    )
```

### Преимущества

✅ **Минимизация потерь** — при сбое на батче N продолжение с батча N, а не с начала

✅ **Прогресс сохраняется** — каждый успешный батч фиксируется

✅ **Большие таблицы** — возможность обработки очень больших таблиц без риска полной переобработки

### Соображения безопасности

Для корректной работы побатчевого коммита необходимо гарантировать:

1. **Идемпотентность функции трансформации**
   - Переобработка батча должна давать тот же результат
   - Функция не должна зависеть от порядка вызовов

2. **Корректный порядок обработки**
   - Батчи должны обрабатываться в порядке возрастания update_ts
   - Это гарантирует, что офсет движется монотонно вперед

3. **Атомарность на уровне батча**
   - Офсет фиксируется только после успешного сохранения **всех** результатов батча
   - Частичная обработка батча не приводит к обновлению офсета

### Статус

⏳ **В планах на следующие версии**

Побатчевый коммит требует тщательного тестирования для гарантии безопасности данных.

---

## ChangeList как транспорт офсетов

```python
@dataclass
class ChangeList:
    changes: Dict[str, IndexDF]
    offsets: Dict[Tuple[str, str], float]  # (transformation_id, table_name) -> max_update_ts
```

**Поток данных:**

1. **store_batch_result()** — вычисляет офсеты для батча, накапливает в ChangeList
2. **executor.run_process_batch()** — собирает ChangeList от всех батчей, объединяет офсеты (MAX)
3. **run_full()** — получает итоговый ChangeList, фиксирует офсеты через update_offsets_bulk()

### Объединение офсетов

При обработке множества батчей офсеты объединяются с помощью MAX:

```python
def extend(self, other: ChangeList) -> ChangeList:
    new_offsets = {**self.offsets}
    for key, offset in other.offsets.items():
        if key in new_offsets:
            new_offsets[key] = max(new_offsets[key], offset)  # MAX!
        else:
            new_offsets[key] = offset
    return ChangeList(changes=..., offsets=new_offsets)
```

**Почему MAX?**

- Гарантирует монотонное движение офсета вперед
- Офсет отражает максимальную обработанную update_ts
- Безопасно при параллельной обработке батчей

---

## Изоляция от run_changelist

**Правило:** `run_changelist` **НИКОГДА** не изменяет глобальные офсеты.

**Почему?**

```python
# Сценарий с проблемой
run_full()  # Офсет = 1702345600

# Пользователь запускает инкрементальную обработку конкретных записей
run_changelist(idx=custom_idx)  # Обработка записей вне очереди

# Если run_changelist изменит офсет → Офсет = 1702345800

# Следующий run_full() пропустит данные между 1702345600 и 1702345800
# ПОТЕРЯ ДАННЫХ ❌
```

**Решение:**

- Только `run_full` изменяет офсеты
- `run_changelist` работает с явно указанным индексом, не влияя на офсеты
- Гарантия: все данные обрабатываются через `run_full`

---

[← Назад к обзору](./offset-optimization.md)
