# Обработка удаленных записей при использовании join_keys в offset-оптимизации

## Проблема

При использовании `join_keys` (filtered join) с внешними ключами, хранящимися в data table, удаленные записи не попадали в `processed_idx` и, как следствие, не удалялись из выходных таблиц.

Причина заключалась в использовании INNER JOIN между meta table и data table для получения значений внешних ключей. Когда запись удалялась, она физически удалялась из data table, но оставалась в meta table с установленным `delete_ts`. INNER JOIN с пустой data table возвращал ноль строк для удаленных записей, поэтому они не попадали в индекс обработанных записей и не удалялись из выходных таблиц, нарушая консистентность данных.

## Решение

Логика обработки изменений и удалений была разделена на два отдельных CTE:

1. **CTE для измененных записей** — использует INNER JOIN с data table для получения актуальных значений внешних ключей из data table. Фильтрация только по `update_ts >= offset`.

2. **CTE для удаленных записей** — выполняет SELECT только из meta table без JOIN с data table. Для колонок внешних ключей подставляется NULL, так как они не требуются для процесса удаления (достаточно первичных ключей из `transform_keys`). Фильтрация по `delete_ts >= offset`.

Оба CTE объединяются через UNION, обеспечивая попадание как измененных, так и удаленных записей в `processed_idx`, что гарантирует их корректную обработку и поддержание консистентности выходных данных.
